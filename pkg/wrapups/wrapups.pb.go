// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pkg/wrapups/wrapups.proto

package wrapups

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//*
// Wrapup represents one wrapup object.
type Wrapup struct {
	// ID of the wrapup object assigned by Elasticsearch.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// title of the paper.
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// wrapup of the paper.
	Wrapup string `protobuf:"bytes,3,opt,name=wrapup,proto3" json:"wrapup,omitempty"`
	// comment of the paper.
	Comment string `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty"`
	// notes of the paper.
	Note string `protobuf:"bytes,5,opt,name=note,proto3" json:"note,omitempty"`
	// timestamp which indicates when this wrapup object is created.
	CreateTime           *timestamp.Timestamp `protobuf:"bytes,6,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Wrapup) Reset()         { *m = Wrapup{} }
func (m *Wrapup) String() string { return proto.CompactTextString(m) }
func (*Wrapup) ProtoMessage()    {}
func (*Wrapup) Descriptor() ([]byte, []int) {
	return fileDescriptor_685ed5c71b2573e9, []int{0}
}

func (m *Wrapup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Wrapup.Unmarshal(m, b)
}
func (m *Wrapup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Wrapup.Marshal(b, m, deterministic)
}
func (m *Wrapup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Wrapup.Merge(m, src)
}
func (m *Wrapup) XXX_Size() int {
	return xxx_messageInfo_Wrapup.Size(m)
}
func (m *Wrapup) XXX_DiscardUnknown() {
	xxx_messageInfo_Wrapup.DiscardUnknown(m)
}

var xxx_messageInfo_Wrapup proto.InternalMessageInfo

func (m *Wrapup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Wrapup) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Wrapup) GetWrapup() string {
	if m != nil {
		return m.Wrapup
	}
	return ""
}

func (m *Wrapup) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Wrapup) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *Wrapup) GetCreateTime() *timestamp.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

//*
// ListWrapupsRequest represents the request message for List operation.
type ListWrapupsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListWrapupsRequest) Reset()         { *m = ListWrapupsRequest{} }
func (m *ListWrapupsRequest) String() string { return proto.CompactTextString(m) }
func (*ListWrapupsRequest) ProtoMessage()    {}
func (*ListWrapupsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_685ed5c71b2573e9, []int{1}
}

func (m *ListWrapupsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListWrapupsRequest.Unmarshal(m, b)
}
func (m *ListWrapupsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListWrapupsRequest.Marshal(b, m, deterministic)
}
func (m *ListWrapupsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListWrapupsRequest.Merge(m, src)
}
func (m *ListWrapupsRequest) XXX_Size() int {
	return xxx_messageInfo_ListWrapupsRequest.Size(m)
}
func (m *ListWrapupsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListWrapupsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListWrapupsRequest proto.InternalMessageInfo

//*
// ListWrapupsResponse represents the response of List operation.
type ListWrapupsResponse struct {
	// number of wrapup objects included in this response.
	Count int32 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// list of wrapup object.
	Wrapups              []*Wrapup `protobuf:"bytes,2,rep,name=wrapups,proto3" json:"wrapups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ListWrapupsResponse) Reset()         { *m = ListWrapupsResponse{} }
func (m *ListWrapupsResponse) String() string { return proto.CompactTextString(m) }
func (*ListWrapupsResponse) ProtoMessage()    {}
func (*ListWrapupsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_685ed5c71b2573e9, []int{2}
}

func (m *ListWrapupsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListWrapupsResponse.Unmarshal(m, b)
}
func (m *ListWrapupsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListWrapupsResponse.Marshal(b, m, deterministic)
}
func (m *ListWrapupsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListWrapupsResponse.Merge(m, src)
}
func (m *ListWrapupsResponse) XXX_Size() int {
	return xxx_messageInfo_ListWrapupsResponse.Size(m)
}
func (m *ListWrapupsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListWrapupsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListWrapupsResponse proto.InternalMessageInfo

func (m *ListWrapupsResponse) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ListWrapupsResponse) GetWrapups() []*Wrapup {
	if m != nil {
		return m.Wrapups
	}
	return nil
}

//*
// GetWrapupRequest represents the request message for Get operation.
type GetWrapupRequest struct {
	// id to fetch specific wrapup object from Elasticsearch server.
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetWrapupRequest) Reset()         { *m = GetWrapupRequest{} }
func (m *GetWrapupRequest) String() string { return proto.CompactTextString(m) }
func (*GetWrapupRequest) ProtoMessage()    {}
func (*GetWrapupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_685ed5c71b2573e9, []int{3}
}

func (m *GetWrapupRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetWrapupRequest.Unmarshal(m, b)
}
func (m *GetWrapupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetWrapupRequest.Marshal(b, m, deterministic)
}
func (m *GetWrapupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWrapupRequest.Merge(m, src)
}
func (m *GetWrapupRequest) XXX_Size() int {
	return xxx_messageInfo_GetWrapupRequest.Size(m)
}
func (m *GetWrapupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWrapupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetWrapupRequest proto.InternalMessageInfo

func (m *GetWrapupRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

//*
// CreateWrapupRequest represents the request message for Create operation.
type CreateWrapupRequest struct {
	// title of paper.
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// wrapup of paper.
	Wrapup string `protobuf:"bytes,2,opt,name=wrapup,proto3" json:"wrapup,omitempty"`
	// comment of paper.
	Comment string `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
	// note of paper.
	Note                 string   `protobuf:"bytes,4,opt,name=note,proto3" json:"note,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateWrapupRequest) Reset()         { *m = CreateWrapupRequest{} }
func (m *CreateWrapupRequest) String() string { return proto.CompactTextString(m) }
func (*CreateWrapupRequest) ProtoMessage()    {}
func (*CreateWrapupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_685ed5c71b2573e9, []int{4}
}

func (m *CreateWrapupRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateWrapupRequest.Unmarshal(m, b)
}
func (m *CreateWrapupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateWrapupRequest.Marshal(b, m, deterministic)
}
func (m *CreateWrapupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateWrapupRequest.Merge(m, src)
}
func (m *CreateWrapupRequest) XXX_Size() int {
	return xxx_messageInfo_CreateWrapupRequest.Size(m)
}
func (m *CreateWrapupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateWrapupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateWrapupRequest proto.InternalMessageInfo

func (m *CreateWrapupRequest) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CreateWrapupRequest) GetWrapup() string {
	if m != nil {
		return m.Wrapup
	}
	return ""
}

func (m *CreateWrapupRequest) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *CreateWrapupRequest) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func init() {
	proto.RegisterType((*Wrapup)(nil), "wrapups.Wrapup")
	proto.RegisterType((*ListWrapupsRequest)(nil), "wrapups.ListWrapupsRequest")
	proto.RegisterType((*ListWrapupsResponse)(nil), "wrapups.ListWrapupsResponse")
	proto.RegisterType((*GetWrapupRequest)(nil), "wrapups.GetWrapupRequest")
	proto.RegisterType((*CreateWrapupRequest)(nil), "wrapups.CreateWrapupRequest")
}

func init() { proto.RegisterFile("pkg/wrapups/wrapups.proto", fileDescriptor_685ed5c71b2573e9) }

var fileDescriptor_685ed5c71b2573e9 = []byte{
	// 347 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x91, 0xcf, 0x4e, 0xf2, 0x40,
	0x14, 0xc5, 0x99, 0x02, 0x25, 0xdc, 0x7e, 0xf9, 0x34, 0x17, 0x62, 0x86, 0x6a, 0x22, 0x99, 0x15,
	0x6e, 0x4a, 0x82, 0x2b, 0xe3, 0xc2, 0x85, 0x0b, 0x13, 0xe3, 0xaa, 0x31, 0xba, 0x34, 0xfc, 0x19,
	0x49, 0x23, 0xed, 0x0c, 0xcc, 0x34, 0x3e, 0x97, 0x8f, 0xe2, 0x1b, 0x99, 0xce, 0x74, 0x0a, 0xd4,
	0xba, 0x82, 0x7b, 0xee, 0xc9, 0x9d, 0x73, 0x7e, 0x85, 0x91, 0xfc, 0x58, 0x4f, 0x3f, 0x77, 0x73,
	0x99, 0x4b, 0xe5, 0x7e, 0x23, 0xb9, 0x13, 0x5a, 0x60, 0xaf, 0x1c, 0xc3, 0xcb, 0xb5, 0x10, 0xeb,
	0x0d, 0x9f, 0x1a, 0x79, 0x91, 0xbf, 0x4f, 0x75, 0x92, 0x72, 0xa5, 0xe7, 0xa9, 0xb4, 0x4e, 0xf6,
	0x45, 0xc0, 0x7f, 0x35, 0x66, 0xfc, 0x0f, 0x5e, 0xb2, 0xa2, 0x64, 0x4c, 0x26, 0xfd, 0xd8, 0x4b,
	0x56, 0x38, 0x84, 0xae, 0x4e, 0xf4, 0x86, 0x53, 0xcf, 0x48, 0x76, 0xc0, 0x33, 0xf0, 0xed, 0x71,
	0xda, 0x36, 0x72, 0x39, 0x21, 0x85, 0xde, 0x52, 0xa4, 0x29, 0xcf, 0x34, 0xed, 0x98, 0x85, 0x1b,
	0x11, 0xa1, 0x93, 0x09, 0xcd, 0x69, 0xd7, 0xc8, 0xe6, 0x3f, 0xde, 0x42, 0xb0, 0xdc, 0xf1, 0xb9,
	0xe6, 0x6f, 0x45, 0x20, 0xea, 0x8f, 0xc9, 0x24, 0x98, 0x85, 0x91, 0x4d, 0x1b, 0xb9, 0xb4, 0xd1,
	0xb3, 0x4b, 0x1b, 0x83, 0xb5, 0x17, 0x02, 0x1b, 0x02, 0x3e, 0x25, 0x4a, 0xdb, 0xd8, 0x2a, 0xe6,
	0xdb, 0x9c, 0x2b, 0xcd, 0x5e, 0x60, 0x70, 0xa4, 0x2a, 0x29, 0x32, 0xc5, 0x8b, 0x16, 0x4b, 0x91,
	0x67, 0xda, 0x14, 0xeb, 0xc6, 0x76, 0xc0, 0x2b, 0x70, 0x88, 0xa8, 0x37, 0x6e, 0x4f, 0x82, 0xd9,
	0x49, 0xe4, 0x08, 0xda, 0x03, 0xb1, 0xdb, 0x33, 0x06, 0xa7, 0x0f, 0xbc, 0x3c, 0x5b, 0xbe, 0x55,
	0x47, 0xc5, 0xb6, 0x30, 0xb8, 0x37, 0xf9, 0x8e, 0x6d, 0x15, 0x41, 0xd2, 0x4c, 0xd0, 0xfb, 0x8b,
	0x60, 0xbb, 0x99, 0x60, 0x67, 0x4f, 0x70, 0xf6, 0x4d, 0xa0, 0x57, 0x76, 0xc5, 0x47, 0x08, 0x0e,
	0xaa, 0xe3, 0x79, 0xd5, 0xe5, 0x37, 0xa6, 0xf0, 0xa2, 0x79, 0x69, 0x69, 0xb1, 0x16, 0xde, 0x40,
	0xbf, 0xaa, 0x8b, 0xa3, 0xca, 0x5c, 0x47, 0x10, 0xd6, 0x81, 0xb1, 0x16, 0xde, 0xc1, 0xbf, 0x43,
	0x0a, 0xb8, 0x7f, 0xaa, 0x01, 0x4e, 0xc3, 0x81, 0x85, 0x6f, 0x3e, 0xfc, 0xf5, 0x4f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x2a, 0x7d, 0x4a, 0x14, 0xda, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WrapupsClient is the client API for Wrapups service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WrapupsClient interface {
	// ListWrapups returns the list of wrapup document stored in Elasticsearch.
	ListWrapups(ctx context.Context, in *ListWrapupsRequest, opts ...grpc.CallOption) (*ListWrapupsResponse, error)
	// GetWrapup returns a wrapup document matched to request.
	GetWrapup(ctx context.Context, in *GetWrapupRequest, opts ...grpc.CallOption) (*Wrapup, error)
	// CreateWrapup creates new wrapup document and stores it in Elasticsearch.
	CreateWrapup(ctx context.Context, in *CreateWrapupRequest, opts ...grpc.CallOption) (*Wrapup, error)
}

type wrapupsClient struct {
	cc *grpc.ClientConn
}

func NewWrapupsClient(cc *grpc.ClientConn) WrapupsClient {
	return &wrapupsClient{cc}
}

func (c *wrapupsClient) ListWrapups(ctx context.Context, in *ListWrapupsRequest, opts ...grpc.CallOption) (*ListWrapupsResponse, error) {
	out := new(ListWrapupsResponse)
	err := c.cc.Invoke(ctx, "/wrapups.Wrapups/ListWrapups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wrapupsClient) GetWrapup(ctx context.Context, in *GetWrapupRequest, opts ...grpc.CallOption) (*Wrapup, error) {
	out := new(Wrapup)
	err := c.cc.Invoke(ctx, "/wrapups.Wrapups/GetWrapup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wrapupsClient) CreateWrapup(ctx context.Context, in *CreateWrapupRequest, opts ...grpc.CallOption) (*Wrapup, error) {
	out := new(Wrapup)
	err := c.cc.Invoke(ctx, "/wrapups.Wrapups/CreateWrapup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WrapupsServer is the server API for Wrapups service.
type WrapupsServer interface {
	// ListWrapups returns the list of wrapup document stored in Elasticsearch.
	ListWrapups(context.Context, *ListWrapupsRequest) (*ListWrapupsResponse, error)
	// GetWrapup returns a wrapup document matched to request.
	GetWrapup(context.Context, *GetWrapupRequest) (*Wrapup, error)
	// CreateWrapup creates new wrapup document and stores it in Elasticsearch.
	CreateWrapup(context.Context, *CreateWrapupRequest) (*Wrapup, error)
}

func RegisterWrapupsServer(s *grpc.Server, srv WrapupsServer) {
	s.RegisterService(&_Wrapups_serviceDesc, srv)
}

func _Wrapups_ListWrapups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWrapupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WrapupsServer).ListWrapups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wrapups.Wrapups/ListWrapups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WrapupsServer).ListWrapups(ctx, req.(*ListWrapupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wrapups_GetWrapup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWrapupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WrapupsServer).GetWrapup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wrapups.Wrapups/GetWrapup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WrapupsServer).GetWrapup(ctx, req.(*GetWrapupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wrapups_CreateWrapup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWrapupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WrapupsServer).CreateWrapup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wrapups.Wrapups/CreateWrapup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WrapupsServer).CreateWrapup(ctx, req.(*CreateWrapupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Wrapups_serviceDesc = grpc.ServiceDesc{
	ServiceName: "wrapups.Wrapups",
	HandlerType: (*WrapupsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListWrapups",
			Handler:    _Wrapups_ListWrapups_Handler,
		},
		{
			MethodName: "GetWrapup",
			Handler:    _Wrapups_GetWrapup_Handler,
		},
		{
			MethodName: "CreateWrapup",
			Handler:    _Wrapups_CreateWrapup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/wrapups/wrapups.proto",
}
